<?php
//dezend by http://www.yunlu99.com/
if ((ob_get_length() === false) && !ini_get('zlib.output_compression') && (ini_get('output_handler') != 'ob_gzhandler') && (ini_get('output_handler') != 'mb_output_handler')) {
	ob_start('ob_gzhandler');
}

header('Cache-Control: public');
header('Pragma: cache');
$offset = 2592000;
$ExpStr = 'Expires: ' . gmdate('D, d M Y H:i:s', time() + $offset) . ' GMT';
$LmStr = 'Last-Modified: ' . gmdate('D, d M Y H:i:s', filemtime(__FILE__)) . ' GMT';
header($ExpStr);
header($LmStr);
header('Content-Type: text/javascr¨©pt; charset: UTF-8');
echo '' . "\r\n" . '/*' . "\r\n" . '	Queue Plug-in' . "\r\n" . '	' . "\r\n" . '	Features:' . "\r\n" . '		*Adds a cancelQueue() method for cancelling the entire queue.' . "\r\n" . '		*All queued files are uploaded when startUpload() is called.' . "\r\n" . '		*If false is returned from uploadComplete then the queue upload is stopped.' . "\r\n" . '		 If false is not returned (strict comparison) then the queue upload is continued.' . "\r\n" . '		*Adds a QueueComplete event that is fired when all the queued files have finished uploading.' . "\r\n" . '		 Set the event handler with the queue_complete_handler setting.' . "\r\n" . '		' . "\r\n" . '	*/' . "\r\n" . '' . "\r\n" . 'var SWFUpload;' . "\r\n" . 'if (typeof(SWFUpload) === "function") {' . "\r\n" . '	SWFUpload.queue = {};' . "\r\n" . '	' . "\r\n" . '	SWFUpload.prototype.initSettings = (function (oldInitSettings) {' . "\r\n" . '		return function () {' . "\r\n" . '			if (typeof(oldInitSettings) === "function") {' . "\r\n" . '				oldInitSettings.call(this);' . "\r\n" . '			}' . "\r\n" . '			' . "\r\n" . '			this.queueSettings = {};' . "\r\n" . '			' . "\r\n" . '			this.queueSettings.queue_cancelled_flag = false;' . "\r\n" . '			this.queueSettings.queue_upload_count = 0;' . "\r\n" . '			' . "\r\n" . '			this.queueSettings.user_upload_complete_handler = this.settings.upload_complete_handler;' . "\r\n" . '			this.queueSettings.user_upload_start_handler = this.settings.upload_start_handler;' . "\r\n" . '			this.settings.upload_complete_handler = SWFUpload.queue.uploadCompleteHandler;' . "\r\n" . '			this.settings.upload_start_handler = SWFUpload.queue.uploadStartHandler;' . "\r\n" . '			' . "\r\n" . '			this.settings.queue_complete_handler = this.settings.queue_complete_handler || null;' . "\r\n" . '		};' . "\r\n" . '	})(SWFUpload.prototype.initSettings);' . "\r\n" . '' . "\r\n" . '	SWFUpload.prototype.startUpload = function (fileID) {' . "\r\n" . '		this.queueSettings.queue_cancelled_flag = false;' . "\r\n" . '		this.callFlash("StartUpload", [fileID]);' . "\r\n" . '	};' . "\r\n" . '' . "\r\n" . '	SWFUpload.prototype.cancelQueue = function () {' . "\r\n" . '		this.queueSettings.queue_cancelled_flag = true;' . "\r\n" . '		this.stopUpload();' . "\r\n" . '		' . "\r\n" . '		var stats = this.getStats();' . "\r\n" . '		while (stats.files_queued > 0) {' . "\r\n" . '			this.cancelUpload();' . "\r\n" . '			stats = this.getStats();' . "\r\n" . '		}' . "\r\n" . '	};' . "\r\n" . '	' . "\r\n" . '	SWFUpload.queue.uploadStartHandler = function (file) {' . "\r\n" . '		var returnValue;' . "\r\n" . '		if (typeof(this.queueSettings.user_upload_start_handler) === "function") {' . "\r\n" . '			returnValue = this.queueSettings.user_upload_start_handler.call(this, file);' . "\r\n" . '		}' . "\r\n" . '		' . "\r\n" . '		// To prevent upload a real "FALSE" value must be returned, otherwise default to a real "TRUE" value.' . "\r\n" . '		returnValue = (returnValue === false) ? false : true;' . "\r\n" . '		' . "\r\n" . '		this.queueSettings.queue_cancelled_flag = !returnValue;' . "\r\n" . '' . "\r\n" . '		return returnValue;' . "\r\n" . '	};' . "\r\n" . '	' . "\r\n" . '	SWFUpload.queue.uploadCompleteHandler = function (file) {' . "\r\n" . '		var user_upload_complete_handler = this.queueSettings.user_upload_complete_handler;' . "\r\n" . '		var continueUpload;' . "\r\n" . '		' . "\r\n" . '		if (file.filestatus === SWFUpload.FILE_STATUS.COMPLETE) {' . "\r\n" . '			this.queueSettings.queue_upload_count++;' . "\r\n" . '		}' . "\r\n" . '' . "\r\n" . '		if (typeof(user_upload_complete_handler) === "function") {' . "\r\n" . '			continueUpload = (user_upload_complete_handler.call(this, file) === false) ? false : true;' . "\r\n" . '		} else if (file.filestatus === SWFUpload.FILE_STATUS.QUEUED) {' . "\r\n" . '			// If the file was stopped and re-queued don\'t restart the upload' . "\r\n" . '			continueUpload = false;' . "\r\n" . '		} else {' . "\r\n" . '			continueUpload = true;' . "\r\n" . '		}' . "\r\n" . '		' . "\r\n" . '		if (continueUpload) {' . "\r\n" . '			var stats = this.getStats();' . "\r\n" . '			if (stats.files_queued > 0 && this.queueSettings.queue_cancelled_flag === false) {' . "\r\n" . '				this.startUpload();' . "\r\n" . '			} else if (this.queueSettings.queue_cancelled_flag === false) {' . "\r\n" . '				this.queueEvent("queue_complete_handler", [this.queueSettings.queue_upload_count]);' . "\r\n" . '				this.queueSettings.queue_upload_count = 0;' . "\r\n" . '			} else {' . "\r\n" . '				this.queueSettings.queue_cancelled_flag = false;' . "\r\n" . '				this.queueSettings.queue_upload_count = 0;' . "\r\n" . '			}' . "\r\n" . '		}' . "\r\n" . '	};' . "\r\n" . '}';

?>
